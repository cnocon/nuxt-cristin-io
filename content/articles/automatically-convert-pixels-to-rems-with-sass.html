<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body vscode-light">
        <hr>
<h2 id="title-automatically-convert-pixels-to-rems-with-sasssummary-sass-essentially-turns-css-into-a-programmatic-language-suddenly-we-can-dynamically-generate-everything-from-comprehensive-utility-class-names-and-styles-to-entire-grid-layouts--in-this-post-well-take-advantage-of-sass-functions-to-convert-pixels-to-rems-without-all-the-ugly-mathdate-2020-06-10t004800zimg-sasspngalt-sass-logocategories-accessibility-scss">title: Automatically Convert Pixels to Rems with SASS<br>
summary: SASS essentially turns CSS into a programmatic language. Suddenly we can dynamically generate everything from comprehensive utility class names and styles to entire grid layouts.  In this post we'll take advantage of SASS functions to convert pixels to rems without all the ugly math.<br>
date: 2020-06-10T00:48:00Z<br>
img: sass.png<br>
alt: SASS Logo<br>
categories: [Accessibility, SCSS]</h2>
<p class="drop-cap">According to <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener noreferrer">Stack Overflow's 2020 Developer Survey</a>, developers have a tendency to dread CSS. I couldn't disagree more! SASS is amazing; It basically turns CSS into a programmatic language. Suddenly we can dynamically generate everything from comprehensive utility class names and styles to entire grid layouts. We can take advantage of some of Sass's features like functions and mixins for creating entire grid layouts and comprehensive utility classes.  But today we'll focus on the smaller example of converting pixels into rems to help ease into SASS.</p>
<p>According to the <a href="http://www.w3.org/TR/2013/CR-css3-values-20130730/#font-relative-lengths" target="_blank" rel="noopener noreferrer">W3C spec</a> the definition for one rem unit is:</p>
<quote>
  <template #quote>One rem is equal to the computed value of the font-size on the root element. When specified on the font-size property of the root element, the rem units refer to the propertyâ€™s initial value.</template>
</quote>
<p>This means that <code>1rem</code> equals the font size of the <code>html</code> element (which for most browsers has a default value of 16px). If you wanted to convert subsequent sizes to rems, you'd have to divide the pixel value by the base size of 16, which isn't easy to do in your head, if you're like me.</p>
<p>Enter SASS! We can create a function to generate the rem value for us.</p>
<snippet lang="scss">
<template #code>
$base-font-size: 16px;
<br />
@function calculate-rem($size) {
  $rem-size: $size / $base-font-size;
  @return #{$rem-size}rem;
}
<br />
h3 {
  font-size: calculate-rem(120px);
}
</template>
</snippet>
<p>In the above code snippet, we set our base font size in a variable for clarity. We also defined a function that takes whatever pixel size we pass it and returns that value in rems.</p>
<p>You can see how to use a function by looking at the <code>h3</code> style declaration. We call the function where we'd normally declare a static value.</p>
<p>When this compiles, the value will be in rems!</p>

    </body>
    </html>